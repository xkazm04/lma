/**
 * Cross-Module Features
 *
 * This file implements the 5 cross-module integration features that
 * connect data across different modules to provide high business value.
 *
 * Features:
 * 1. Document → Compliance Auto-Population
 * 2. Covenant Breach → Deal Impact Predictor
 * 3. Compliance Agent → Deal Acceleration
 * 4. Covenant Network → Portfolio Contagion
 * 5. Trading Settlement → Cash Flow Forecast
 */

import {
  borrowers,
  facilities,
  documents,
  deals,
  trades,
  covenants,
  complianceEvents,
  futureDate,
  pastDate,
  type RegisteredBorrower,
  type RegisteredFacility,
  type RegisteredDocument,
  type RegisteredDeal,
  type RegisteredTrade,
  type RegisteredCovenant,
  type RegisteredComplianceEvent,
  BORROWER_IDS,
  FACILITY_IDS,
  COVENANT_IDS,
  DEAL_IDS,
  TRADE_IDS,
} from './registry';

// =============================================================================
// Feature 1: Document → Compliance Auto-Population
// =============================================================================
// When a document is uploaded and processed, automatically extract covenants
// and populate the compliance calendar with relevant events.

export interface ExtractedCovenant {
  documentId: string;
  facilityId: string;
  borrowerId: string;
  covenantType: string;
  description: string;
  threshold: string;
  testFrequency: 'monthly' | 'quarterly' | 'annually';
  firstTestDate: string;
  confidence: number;
}

export interface GeneratedComplianceEvent {
  id: string;
  sourceDocumentId: string;
  facilityId: string;
  borrowerId: string;
  covenantType: string;
  eventType: 'covenant_test' | 'financial_delivery' | 'certificate_due';
  description: string;
  dueDate: string;
  autoGenerated: true;
}

/**
 * Mock extraction of covenants from a document
 */
export function extractCovenantsFromDocument(documentId: string): ExtractedCovenant[] {
  const doc = documents[documentId];
  if (!doc || doc.status !== 'completed') return [];

  const facility = facilities[doc.facilityId];
  if (!facility) return [];

  // Mock extracted covenants based on facility covenant types
  return facility.covenantTypes.map((type, index) => ({
    documentId: doc.id,
    facilityId: doc.facilityId,
    borrowerId: doc.borrowerId,
    covenantType: type,
    description: `${type} covenant extracted from ${doc.filename}`,
    threshold: type.includes('Ratio') ? '≤ 4.50x' : type.includes('Coverage') ? '≥ 2.50x' : '≥ $50M',
    testFrequency: 'quarterly' as const,
    firstTestDate: futureDate(30 + index * 30),
    confidence: 0.85 + Math.random() * 0.1,
  }));
}

/**
 * Generate compliance events from extracted covenants
 */
export function generateComplianceEventsFromDocument(documentId: string): GeneratedComplianceEvent[] {
  const extractedCovenants = extractCovenantsFromDocument(documentId);
  const events: GeneratedComplianceEvent[] = [];

  extractedCovenants.forEach((covenant, index) => {
    // Generate quarterly test events for the next year
    for (let quarter = 0; quarter < 4; quarter++) {
      events.push({
        id: `auto-${documentId}-${index}-q${quarter}`,
        sourceDocumentId: documentId,
        facilityId: covenant.facilityId,
        borrowerId: covenant.borrowerId,
        covenantType: covenant.covenantType,
        eventType: 'covenant_test',
        description: `Q${quarter + 1} ${covenant.covenantType} Test`,
        dueDate: futureDate(30 + quarter * 90),
        autoGenerated: true,
      });
    }
  });

  // Add financial delivery events
  const doc = documents[documentId];
  if (doc) {
    events.push({
      id: `auto-${documentId}-fin-annual`,
      sourceDocumentId: documentId,
      facilityId: doc.facilityId,
      borrowerId: doc.borrowerId,
      covenantType: 'Financial Reporting',
      eventType: 'financial_delivery',
      description: 'Annual Audited Financial Statements',
      dueDate: futureDate(90),
      autoGenerated: true,
    });

    events.push({
      id: `auto-${documentId}-cert-monthly`,
      sourceDocumentId: documentId,
      facilityId: doc.facilityId,
      borrowerId: doc.borrowerId,
      covenantType: 'Compliance Certificate',
      eventType: 'certificate_due',
      description: 'Monthly Compliance Certificate',
      dueDate: futureDate(30),
      autoGenerated: true,
    });
  }

  return events;
}

/**
 * Get all auto-generated compliance events for a facility
 */
export function getAutoPopulatedComplianceEvents(facilityId: string): GeneratedComplianceEvent[] {
  const facilityDocs = Object.values(documents).filter(
    (d) => d.facilityId === facilityId && d.status === 'completed'
  );

  return facilityDocs.flatMap((doc) => generateComplianceEventsFromDocument(doc.id));
}

// =============================================================================
// Feature 2: Covenant Breach → Deal Impact Predictor
// =============================================================================
// When a covenant breach is detected, predict the impact on active deals
// involving the same borrower.

export interface DealImpactPrediction {
  dealId: string;
  dealName: string;
  borrowerId: string;
  borrowerName: string;
  breachedCovenantId: string;
  breachedCovenantType: string;
  impactLevel: 'none' | 'low' | 'medium' | 'high' | 'critical';
  impactDescription: string;
  affectedTerms: string[];
  recommendedActions: string[];
  estimatedDelayDays: number;
  riskScore: number; // 0-100
}

/**
 * Predict deal impact from a covenant breach
 */
export function predictDealImpactFromBreach(covenantId: string): DealImpactPrediction[] {
  const covenant = covenants[covenantId];
  if (!covenant || covenant.status !== 'breached') return [];

  const borrower = borrowers[covenant.borrowerId];
  if (!borrower) return [];

  // Find all active deals for this borrower
  const borrowerDeals = Object.values(deals).filter(
    (d) => d.borrowerId === covenant.borrowerId && ['draft', 'active'].includes(d.status)
  );

  return borrowerDeals.map((deal) => {
    const isDirectFacility = deal.facilityId === covenant.facilityId;
    const impactLevel = isDirectFacility ? 'critical' : 'high';
    const riskScore = isDirectFacility ? 85 : 65;

    return {
      dealId: deal.id,
      dealName: deal.name,
      borrowerId: covenant.borrowerId,
      borrowerName: borrower.name,
      breachedCovenantId: covenant.id,
      breachedCovenantType: covenant.type,
      impactLevel,
      impactDescription: isDirectFacility
        ? `Direct covenant breach on facility underlying this deal. ${covenant.type} at ${covenant.currentValue} vs threshold ${covenant.threshold}.`
        : `Borrower-level covenant breach may affect lender appetite and pricing. ${covenant.type} breached on related facility.`,
      affectedTerms: isDirectFacility
        ? ['Pricing Terms', 'Financial Covenants', 'Conditions Precedent']
        : ['Pricing Terms', 'Lender Commitments'],
      recommendedActions: [
        'Notify all deal participants of covenant breach',
        'Request updated financials from borrower',
        'Consider pricing adjustment to reflect increased risk',
        isDirectFacility ? 'Evaluate waiver or amendment requirements' : 'Monitor borrower creditworthiness',
      ],
      estimatedDelayDays: isDirectFacility ? 30 : 14,
      riskScore,
    };
  });
}

/**
 * Get all deal impacts across the portfolio from breached covenants
 */
export function getAllBreachDealImpacts(): DealImpactPrediction[] {
  const breachedCovenants = Object.values(covenants).filter((c) => c.status === 'breached');
  return breachedCovenants.flatMap((covenant) => predictDealImpactFromBreach(covenant.id));
}

/**
 * Get borrowers with both breached covenants and active deals
 */
export function getBorrowersWithBreachAndActiveDeals(): Array<{
  borrower: RegisteredBorrower;
  breachedCovenants: RegisteredCovenant[];
  activeDeals: RegisteredDeal[];
  totalImpact: DealImpactPrediction[];
}> {
  const results: Array<{
    borrower: RegisteredBorrower;
    breachedCovenants: RegisteredCovenant[];
    activeDeals: RegisteredDeal[];
    totalImpact: DealImpactPrediction[];
  }> = [];

  Object.values(borrowers).forEach((borrower) => {
    const breachedCovenants = Object.values(covenants).filter(
      (c) => c.borrowerId === borrower.id && c.status === 'breached'
    );
    const activeDeals = Object.values(deals).filter(
      (d) => d.borrowerId === borrower.id && ['draft', 'active'].includes(d.status)
    );

    if (breachedCovenants.length > 0 && activeDeals.length > 0) {
      const totalImpact = breachedCovenants.flatMap((c) => predictDealImpactFromBreach(c.id));
      results.push({ borrower, breachedCovenants, activeDeals, totalImpact });
    }
  });

  return results;
}

// =============================================================================
// Feature 3: Compliance Agent → Deal Acceleration
// =============================================================================
// AI agent identifies compliance blockers that are affecting deal progress.

export interface DealBlocker {
  id: string;
  dealId: string;
  dealName: string;
  blockerType: 'covenant_breach' | 'missing_consent' | 'overdue_delivery' | 'pending_waiver' | 'credit_concern';
  severity: 'low' | 'medium' | 'high' | 'critical';
  description: string;
  relatedFacilityId: string | null;
  relatedCovenantId: string | null;
  relatedComplianceEventId: string | null;
  resolutionSteps: string[];
  estimatedResolutionDays: number;
  autoDetected: true;
}

export interface DealAccelerationSuggestion {
  dealId: string;
  dealName: string;
  currentBlockers: DealBlocker[];
  accelerationOpportunities: string[];
  parallelWorkstreams: string[];
  riskMitigation: string[];
  projectedClosingDate: string;
  confidenceScore: number;
}

/**
 * Detect compliance blockers for a deal
 */
export function detectDealBlockers(dealId: string): DealBlocker[] {
  const deal = deals[dealId];
  if (!deal) return [];

  const blockers: DealBlocker[] = [];
  const borrower = borrowers[deal.borrowerId];

  // Check for covenant breaches
  const borrowerCovenants = Object.values(covenants).filter(
    (c) => c.borrowerId === deal.borrowerId
  );

  borrowerCovenants
    .filter((c) => c.status === 'breached')
    .forEach((covenant) => {
      blockers.push({
        id: `blocker-${deal.id}-breach-${covenant.id}`,
        dealId: deal.id,
        dealName: deal.name,
        blockerType: 'covenant_breach',
        severity: covenant.facilityId === deal.facilityId ? 'critical' : 'high',
        description: `${covenant.type} breach: ${covenant.currentValue} vs threshold ${covenant.threshold}`,
        relatedFacilityId: covenant.facilityId,
        relatedCovenantId: covenant.id,
        relatedComplianceEventId: null,
        resolutionSteps: [
          'Obtain waiver from lenders',
          'Negotiate covenant reset',
          'Provide additional security',
        ],
        estimatedResolutionDays: 21,
        autoDetected: true,
      });
    });

  // Check for pending waivers
  const pendingWaivers = complianceEvents.filter(
    (e) =>
      e.borrowerId === deal.borrowerId &&
      e.type === 'waiver_expiration' &&
      e.status === 'pending'
  );

  pendingWaivers.forEach((event) => {
    blockers.push({
      id: `blocker-${deal.id}-waiver-${event.id}`,
      dealId: deal.id,
      dealName: deal.name,
      blockerType: 'pending_waiver',
      severity: 'high',
      description: event.description,
      relatedFacilityId: event.facilityId,
      relatedCovenantId: event.covenantId,
      relatedComplianceEventId: event.id,
      resolutionSteps: [
        'Expedite waiver extension negotiation',
        'Prepare fallback plan if waiver expires',
      ],
      estimatedResolutionDays: 14,
      autoDetected: true,
    });
  });

  // Check for overdue compliance deliveries
  const overdueEvents = complianceEvents.filter(
    (e) =>
      e.borrowerId === deal.borrowerId &&
      e.status === 'overdue' &&
      ['financial_delivery', 'certificate_due'].includes(e.type)
  );

  overdueEvents.forEach((event) => {
    blockers.push({
      id: `blocker-${deal.id}-overdue-${event.id}`,
      dealId: deal.id,
      dealName: deal.name,
      blockerType: 'overdue_delivery',
      severity: 'medium',
      description: `Overdue: ${event.description}`,
      relatedFacilityId: event.facilityId,
      relatedCovenantId: null,
      relatedComplianceEventId: event.id,
      resolutionSteps: [
        'Follow up with borrower on delivery timeline',
        'Escalate to relationship manager',
      ],
      estimatedResolutionDays: 7,
      autoDetected: true,
    });
  });

  // Check borrower credit concerns
  if (borrower && borrower.riskLevel === 'critical') {
    blockers.push({
      id: `blocker-${deal.id}-credit`,
      dealId: deal.id,
      dealName: deal.name,
      blockerType: 'credit_concern',
      severity: 'critical',
      description: `Borrower ${borrower.name} rated as critical risk level`,
      relatedFacilityId: null,
      relatedCovenantId: null,
      relatedComplianceEventId: null,
      resolutionSteps: [
        'Conduct enhanced due diligence',
        'Request additional collateral',
        'Consider deal restructuring',
      ],
      estimatedResolutionDays: 30,
      autoDetected: true,
    });
  }

  return blockers;
}

/**
 * Generate acceleration suggestions for a deal
 */
export function generateDealAccelerationSuggestions(dealId: string): DealAccelerationSuggestion {
  const deal = deals[dealId];
  if (!deal) {
    return {
      dealId,
      dealName: 'Unknown Deal',
      currentBlockers: [],
      accelerationOpportunities: [],
      parallelWorkstreams: [],
      riskMitigation: [],
      projectedClosingDate: futureDate(90),
      confidenceScore: 0,
    };
  }

  const blockers = detectDealBlockers(dealId);
  const criticalBlockers = blockers.filter((b) => b.severity === 'critical');
  const hasNoBlockers = blockers.length === 0;

  const baseDelayDays = criticalBlockers.length * 21 + blockers.filter((b) => b.severity === 'high').length * 14;
  const targetDate = deal.targetCloseDate || futureDate(60);

  return {
    dealId: deal.id,
    dealName: deal.name,
    currentBlockers: blockers,
    accelerationOpportunities: hasNoBlockers
      ? [
          'Deal is on track - no blockers detected',
          'Consider early documentation drafting',
          'Pre-arrange consent from key lenders',
        ]
      : [
          'Parallel process waiver and deal documentation',
          'Engage borrower early on financial deliveries',
          'Pre-negotiate covenant levels to avoid last-minute issues',
        ],
    parallelWorkstreams: [
      'Documentation drafting',
      'Lender syndication outreach',
      'Regulatory approvals (if applicable)',
      'Collateral perfection',
    ],
    riskMitigation: blockers.map((b) => `Address ${b.blockerType}: ${b.resolutionSteps[0]}`),
    projectedClosingDate: futureDate(
      Math.max(
        14,
        deal.targetCloseDate
          ? Math.ceil((new Date(deal.targetCloseDate).getTime() - Date.now()) / (1000 * 60 * 60 * 24)) + baseDelayDays
          : 60 + baseDelayDays
      )
    ),
    confidenceScore: hasNoBlockers ? 92 : Math.max(45, 85 - blockers.length * 10),
  };
}

/**
 * Get all deals with acceleration analysis
 */
export function getAllDealAccelerationAnalysis(): DealAccelerationSuggestion[] {
  return Object.values(deals)
    .filter((d) => ['draft', 'active'].includes(d.status))
    .map((d) => generateDealAccelerationSuggestions(d.id));
}

// =============================================================================
// Feature 4: Covenant Network → Portfolio Contagion
// =============================================================================
// Covenant network analysis feeds portfolio-wide contagion risk assessment.

export interface CovenantCorrelation {
  covenant1Id: string;
  covenant2Id: string;
  correlationType: 'same_borrower' | 'same_industry' | 'same_geography' | 'cross_default';
  correlationStrength: number; // 0-1
  description: string;
}

export interface ContagionRisk {
  sourceBorrowerId: string;
  sourceBorrowerName: string;
  sourceCovenantId: string;
  sourceCovenantType: string;
  affectedBorrowers: Array<{
    borrowerId: string;
    borrowerName: string;
    riskLevel: 'low' | 'medium' | 'high' | 'critical';
    exposure: number;
    contagionPath: string;
  }>;
  totalPortfolioExposure: number;
  contagionProbability: number;
  recommendedActions: string[];
}

export interface PortfolioContagionSummary {
  totalBorrowers: number;
  atRiskBorrowers: number;
  totalExposure: number;
  atRiskExposure: number;
  contagionRisks: ContagionRisk[];
  networkDensity: number; // How interconnected the portfolio is
  topRiskClusters: Array<{
    industry: string;
    borrowerCount: number;
    totalExposure: number;
    averageRisk: number;
  }>;
}

/**
 * Calculate covenant correlations across the portfolio
 */
export function calculateCovenantCorrelations(): CovenantCorrelation[] {
  const correlations: CovenantCorrelation[] = [];
  const covenantList = Object.values(covenants);

  for (let i = 0; i < covenantList.length; i++) {
    for (let j = i + 1; j < covenantList.length; j++) {
      const cov1 = covenantList[i];
      const cov2 = covenantList[j];
      const borrower1 = borrowers[cov1.borrowerId];
      const borrower2 = borrowers[cov2.borrowerId];

      if (!borrower1 || !borrower2) continue;

      // Same borrower correlation
      if (cov1.borrowerId === cov2.borrowerId) {
        correlations.push({
          covenant1Id: cov1.id,
          covenant2Id: cov2.id,
          correlationType: 'same_borrower',
          correlationStrength: 0.95,
          description: `Both covenants belong to ${borrower1.name}`,
        });
      }

      // Same industry correlation
      if (borrower1.industry === borrower2.industry && cov1.borrowerId !== cov2.borrowerId) {
        correlations.push({
          covenant1Id: cov1.id,
          covenant2Id: cov2.id,
          correlationType: 'same_industry',
          correlationStrength: 0.6,
          description: `Both borrowers in ${borrower1.industry} sector`,
        });
      }

      // Same geography correlation
      if (borrower1.geography === borrower2.geography && cov1.borrowerId !== cov2.borrowerId) {
        correlations.push({
          covenant1Id: cov1.id,
          covenant2Id: cov2.id,
          correlationType: 'same_geography',
          correlationStrength: 0.4,
          description: `Both borrowers in ${borrower1.geography} region`,
        });
      }
    }
  }

  return correlations;
}

/**
 * Assess contagion risk from a breached covenant
 */
export function assessContagionRisk(covenantId: string): ContagionRisk | null {
  const covenant = covenants[covenantId];
  if (!covenant || covenant.status !== 'breached') return null;

  const sourceBorrower = borrowers[covenant.borrowerId];
  if (!sourceBorrower) return null;

  const correlations = calculateCovenantCorrelations().filter(
    (c) => c.covenant1Id === covenantId || c.covenant2Id === covenantId
  );

  // Find affected borrowers through correlations
  const affectedBorrowerIds = new Set<string>();
  correlations.forEach((corr) => {
    const relatedCovenantId = corr.covenant1Id === covenantId ? corr.covenant2Id : corr.covenant1Id;
    const relatedCovenant = covenants[relatedCovenantId];
    if (relatedCovenant && relatedCovenant.borrowerId !== covenant.borrowerId) {
      affectedBorrowerIds.add(relatedCovenant.borrowerId);
    }
  });

  const affectedBorrowers = Array.from(affectedBorrowerIds).map((borrowerId) => {
    const borrower = borrowers[borrowerId];
    const borrowerFacilities = Object.values(facilities).filter((f) => f.borrowerId === borrowerId);
    const totalExposure = borrowerFacilities.reduce((sum, f) => sum + f.amount, 0);

    // Determine contagion path
    const sameIndustry = borrower?.industry === sourceBorrower.industry;
    const sameGeography = borrower?.geography === sourceBorrower.geography;
    let contagionPath = 'Indirect correlation';
    if (sameIndustry && sameGeography) {
      contagionPath = `Same industry (${borrower?.industry}) and geography (${borrower?.geography})`;
    } else if (sameIndustry) {
      contagionPath = `Same industry (${borrower?.industry})`;
    } else if (sameGeography) {
      contagionPath = `Same geography (${borrower?.geography})`;
    }

    return {
      borrowerId,
      borrowerName: borrower?.name || 'Unknown',
      riskLevel: borrower?.riskLevel || 'medium',
      exposure: totalExposure,
      contagionPath,
    };
  });

  const totalPortfolioExposure = affectedBorrowers.reduce((sum, b) => sum + b.exposure, 0);

  return {
    sourceBorrowerId: covenant.borrowerId,
    sourceBorrowerName: sourceBorrower.name,
    sourceCovenantId: covenant.id,
    sourceCovenantType: covenant.type,
    affectedBorrowers,
    totalPortfolioExposure,
    contagionProbability: 0.35 + Math.random() * 0.3, // Mock probability
    recommendedActions: [
      'Increase monitoring frequency for correlated borrowers',
      'Review covenant headroom across affected facilities',
      'Prepare early warning communications to relationship managers',
      'Consider portfolio rebalancing to reduce concentration risk',
    ],
  };
}

/**
 * Get portfolio-wide contagion summary
 */
export function getPortfolioContagionSummary(): PortfolioContagionSummary {
  const allBorrowers = Object.values(borrowers);
  const allFacilities = Object.values(facilities);
  const breachedCovenants = Object.values(covenants).filter((c) => c.status === 'breached');

  const totalExposure = allFacilities.reduce((sum, f) => sum + f.amount, 0);
  const atRiskBorrowerIds = new Set(breachedCovenants.map((c) => c.borrowerId));
  const atRiskFacilities = allFacilities.filter((f) => atRiskBorrowerIds.has(f.borrowerId));
  const atRiskExposure = atRiskFacilities.reduce((sum, f) => sum + f.amount, 0);

  const contagionRisks = breachedCovenants
    .map((c) => assessContagionRisk(c.id))
    .filter((r): r is ContagionRisk => r !== null);

  // Calculate industry clusters
  const industryMap = new Map<string, { borrowers: RegisteredBorrower[]; exposure: number }>();
  allBorrowers.forEach((b) => {
    const existing = industryMap.get(b.industry) || { borrowers: [], exposure: 0 };
    const borrowerExposure = allFacilities
      .filter((f) => f.borrowerId === b.id)
      .reduce((sum, f) => sum + f.amount, 0);
    existing.borrowers.push(b);
    existing.exposure += borrowerExposure;
    industryMap.set(b.industry, existing);
  });

  const topRiskClusters = Array.from(industryMap.entries())
    .map(([industry, data]) => ({
      industry,
      borrowerCount: data.borrowers.length,
      totalExposure: data.exposure,
      averageRisk:
        data.borrowers.reduce((sum, b) => {
          const riskValue = { low: 1, medium: 2, high: 3, critical: 4 }[b.riskLevel];
          return sum + riskValue;
        }, 0) / data.borrowers.length,
    }))
    .sort((a, b) => b.averageRisk - a.averageRisk);

  return {
    totalBorrowers: allBorrowers.length,
    atRiskBorrowers: atRiskBorrowerIds.size,
    totalExposure,
    atRiskExposure,
    contagionRisks,
    networkDensity: calculateCovenantCorrelations().length / (Object.keys(covenants).length * (Object.keys(covenants).length - 1) / 2),
    topRiskClusters,
  };
}

// =============================================================================
// Feature 5: Trading Settlement → Cash Flow Forecast
// =============================================================================
// Settlement calendar drives portfolio-wide cash flow forecasting.

export interface DailySettlement {
  date: string;
  tradeId: string;
  tradeReference: string;
  borrowerName: string;
  facilityName: string;
  counterparty: string;
  isBuyer: boolean;
  amount: number;
  netAmount: number; // Positive = inflow, negative = outflow
}

export interface DailyCashFlowForecast {
  date: string;
  settlements: DailySettlement[];
  totalInflows: number;
  totalOutflows: number;
  netPosition: number;
  cumulativePosition: number;
  riskLevel: 'low' | 'medium' | 'high' | 'critical';
  alerts: string[];
}

export interface CashFlowForecastSummary {
  forecastPeriodDays: number;
  dailyForecasts: DailyCashFlowForecast[];
  peakOutflowDate: string;
  peakOutflowAmount: number;
  peakInflowDate: string;
  peakInflowAmount: number;
  lowestNetPositionDate: string;
  lowestNetPosition: number;
  totalExpectedInflows: number;
  totalExpectedOutflows: number;
  netForecast: number;
  liquidityAlerts: string[];
}

/**
 * Generate daily settlement data for forecasting
 */
export function getDailySettlements(forecastDays: number = 30): Map<string, DailySettlement[]> {
  const settlementsByDate = new Map<string, DailySettlement[]>();
  const pendingTrades = Object.values(trades).filter(
    (t) =>
      t.settlementDate &&
      !['settled', 'cancelled', 'failed'].includes(t.status)
  );

  pendingTrades.forEach((trade) => {
    if (!trade.settlementDate) return;

    const settlementDate = trade.settlementDate;
    const facility = facilities[trade.facilityId];
    const borrower = borrowers[trade.borrowerId];

    // Calculate net amount based on trade price
    const settlementAmount = (trade.tradeAmount * trade.tradePrice) / 100;
    const netAmount = trade.isBuyer ? -settlementAmount : settlementAmount; // Buyer pays out, seller receives

    const settlement: DailySettlement = {
      date: settlementDate,
      tradeId: trade.id,
      tradeReference: trade.tradeReference,
      borrowerName: borrower?.name || 'Unknown',
      facilityName: facility?.name || 'Unknown',
      counterparty: trade.isBuyer ? trade.sellerName : trade.buyerName,
      isBuyer: trade.isBuyer,
      amount: settlementAmount,
      netAmount,
    };

    const existing = settlementsByDate.get(settlementDate) || [];
    existing.push(settlement);
    settlementsByDate.set(settlementDate, existing);
  });

  return settlementsByDate;
}

/**
 * Generate cash flow forecast
 */
export function generateCashFlowForecast(forecastDays: number = 30): CashFlowForecastSummary {
  const settlementsByDate = getDailySettlements(forecastDays);
  const dailyForecasts: DailyCashFlowForecast[] = [];

  let cumulativePosition = 0;
  let peakOutflow = { date: '', amount: 0 };
  let peakInflow = { date: '', amount: 0 };
  let lowestNetPosition = { date: '', amount: Infinity };
  let totalInflows = 0;
  let totalOutflows = 0;

  // Generate forecast for each day
  for (let i = 0; i < forecastDays; i++) {
    const date = futureDate(i);
    const settlements = settlementsByDate.get(date) || [];

    const dayInflows = settlements
      .filter((s) => s.netAmount > 0)
      .reduce((sum, s) => sum + s.netAmount, 0);

    const dayOutflows = Math.abs(
      settlements.filter((s) => s.netAmount < 0).reduce((sum, s) => sum + s.netAmount, 0)
    );

    const netPosition = dayInflows - dayOutflows;
    cumulativePosition += netPosition;

    totalInflows += dayInflows;
    totalOutflows += dayOutflows;

    // Track peaks
    if (dayOutflows > peakOutflow.amount) {
      peakOutflow = { date, amount: dayOutflows };
    }
    if (dayInflows > peakInflow.amount) {
      peakInflow = { date, amount: dayInflows };
    }
    if (cumulativePosition < lowestNetPosition.amount) {
      lowestNetPosition = { date, amount: cumulativePosition };
    }

    // Determine risk level
    let riskLevel: 'low' | 'medium' | 'high' | 'critical' = 'low';
    const alerts: string[] = [];

    if (dayOutflows > 20_000_000) {
      riskLevel = 'critical';
      alerts.push(`High outflow day: $${(dayOutflows / 1_000_000).toFixed(1)}M`);
    } else if (dayOutflows > 10_000_000) {
      riskLevel = 'high';
      alerts.push(`Significant outflow: $${(dayOutflows / 1_000_000).toFixed(1)}M`);
    } else if (dayOutflows > 5_000_000) {
      riskLevel = 'medium';
    }

    if (settlements.length > 3) {
      alerts.push(`Multiple settlements (${settlements.length}) on this date`);
    }

    dailyForecasts.push({
      date,
      settlements,
      totalInflows: dayInflows,
      totalOutflows: dayOutflows,
      netPosition,
      cumulativePosition,
      riskLevel,
      alerts,
    });
  }

  // Generate liquidity alerts
  const liquidityAlerts: string[] = [];

  if (peakOutflow.amount > 15_000_000) {
    liquidityAlerts.push(
      `Peak outflow of $${(peakOutflow.amount / 1_000_000).toFixed(1)}M expected on ${peakOutflow.date}`
    );
  }

  if (lowestNetPosition.amount < -10_000_000) {
    liquidityAlerts.push(
      `Cumulative position may reach -$${(Math.abs(lowestNetPosition.amount) / 1_000_000).toFixed(1)}M on ${lowestNetPosition.date}`
    );
  }

  const criticalDays = dailyForecasts.filter((f) => f.riskLevel === 'critical');
  if (criticalDays.length > 0) {
    liquidityAlerts.push(`${criticalDays.length} critical settlement days in forecast period`);
  }

  return {
    forecastPeriodDays: forecastDays,
    dailyForecasts,
    peakOutflowDate: peakOutflow.date || futureDate(0),
    peakOutflowAmount: peakOutflow.amount,
    peakInflowDate: peakInflow.date || futureDate(0),
    peakInflowAmount: peakInflow.amount,
    lowestNetPositionDate: lowestNetPosition.date || futureDate(0),
    lowestNetPosition: lowestNetPosition.amount === Infinity ? 0 : lowestNetPosition.amount,
    totalExpectedInflows: totalInflows,
    totalExpectedOutflows: totalOutflows,
    netForecast: totalInflows - totalOutflows,
    liquidityAlerts,
  };
}

/**
 * Get cash flow impact from a specific trade
 */
export function getTradeSettlementImpact(tradeId: string): {
  trade: RegisteredTrade | undefined;
  settlementDate: string | null;
  netImpact: number;
  fundingRequired: number;
  dayOfSettlement: DailyCashFlowForecast | null;
} {
  const trade = trades[tradeId];
  if (!trade || !trade.settlementDate) {
    return {
      trade: undefined,
      settlementDate: null,
      netImpact: 0,
      fundingRequired: 0,
      dayOfSettlement: null,
    };
  }

  const settlementAmount = (trade.tradeAmount * trade.tradePrice) / 100;
  const netImpact = trade.isBuyer ? -settlementAmount : settlementAmount;
  const fundingRequired = trade.isBuyer ? settlementAmount : 0;

  const forecast = generateCashFlowForecast(30);
  const dayOfSettlement = forecast.dailyForecasts.find((f) => f.date === trade.settlementDate) || null;

  return {
    trade,
    settlementDate: trade.settlementDate,
    netImpact,
    fundingRequired,
    dayOfSettlement,
  };
}
